## JWT

### Token based authentication

Tokens are base64 encoded not encrypted. This means we can easily encode the header and payload data with any other key.

> So encoding is like translating between languages - you don't need a secret key, you just need to know the rules.

**So how does the server find the authenticity of the token?**

The digital signature does that. Only the server has access to the private key. Even if a hacker creates a fake token w/o a correct key; the server can detect that during the verification process.

> The 3rd part of the JWT is the signature which is created using the encoded header + encoded payload + the secret key on the server.

### Issues with JWT

**Weak algorithms**

- Give developers too many algorithms to choose
- Some algorithms are vulnerable:
    - RSA PKCSv1.5: padding oracle attack
    - ECDSA: invalid-curve attack

**Trivial foregery**

Not careful during the implementation, choose poorly implemented library

It incldues the signing algorithm in the header; The attack can set the "alg" header to "none" to bypass the signature step

Set the algorithm header to symmetric one i.e. HS256 while server normally uses RSA public key (asymetric)

The vulnerability exists in buggy JWT libraries that might:
- Skip signature verification entirely when they see "HS256"
- Have implementation bugs that don't properly compare signatures
- Use weak verification that can be bypassed

> Always check the algorithm in the code while verifying the token

## PASETO

Why PASETO is better than JWT

- Provides strong signing algorithm out of the box
- Developers don't choose the algorithm; need to select the PASETO versions
- Each version has one strong cipehr suite 
- Only 2 most recent versions are accepted
- v1 is compatible for legacy systems

> So the "alg" is not mentioned in the header. Everything in the token is also authenticated with AEAD; not possible to tamper with.

### Create an verify tokens

We can create a [maker.go](../token/maker.go) file that contains a Maker interface with `CreateToken` and `VerifyToken` methods.

And a struct Payload with the following fields:
```go
type Payload struct {
	ID        string    `json:"id"`
	Username  string    `json:"username"`
	IssuedAt  time.Time `json:"issued_at"`
	ExpiredAt time.Time `json:"expired_at"`
}
```

The [payload.go](../token/payload.go) file holds custom errros and NewPayload method that generates the payload. It takes `username` and `duration` as input; the rest is generated by the system.

The [jwt_maker](../token/jwt_maker.go) has a `NewJwtMaker` returns a `Maker` interface and an error.
```go
maker := &JWTMaker{secretKey}
```

Since, this is a Maker interface; we need to implement the `CreateToken` and `VerifyToken` methods.

## Using PASETO

Install paseto using

```go
github.com/o1egl/paseto
```

> PasetoV2 uses `ChaCha20-Poly1305` algorithm to encrypt paylaod

The implementation will be similar to jwt_maker. Create a [paseto_maker.go](../token/paseto_maker.go)

We create a `PasetoMaker` interace

```go
type PasetoMaker struct {
	paseto       *paseto.V2
	symmetricKey []byte
}
```

The `NewPasetoMaker` will take secret key; which is of fixed 32 bytes.

And now implement the `CreateToken` and `VerifyToken` methods.

Everything is handled by PASETO internall so we only need to call the Encrypt and Decrypt methods.

```go
// Encrypt the payload
maker.paseto.Encrypt(maker.symmetricKey, payload, nil)

// Decrypt the payload
maker.paseto.Decrypt(token, maker.symmetricKey, payload, nil)
```

## Auth Middleware

Create a autMiddleware function under [middleware.go](../api/middleware.go). This will check for authorization header format and decode the token.

Inside the function we call the `tokenMaker.VerifyToken` method. 

```go
accessToken := fields[1]
payload, err := tokenMaker.VerifyToken(accessToken)
if err != nil {
	ctx.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse(err))
	return
}

ctx.Set(authorizationPayloadKey, payload)
ctx.Next()
```

> This `gin.HandlerFunc` is not of type `http.HandlerFunc`.

Now apply this middleware we need to use `router.Group` to use the middleware function on common set of routes.

```go
authRoutes := router.Group("/").Use(authMiddleware(server.tokenMaker))

// Create account
authRoutes.POST("/accounts", server.createAccount)
// Get an account
authRoutes.GET("/accounts/:id", server.getAccount)
// Get accounts
authRoutes.GET("/accounts", server.getAccounts)
// Transfer
authRoutes.POST("/transfers", server.createTransfer)
```
